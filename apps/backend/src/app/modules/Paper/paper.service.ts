import QueryBuilder from "../../builders/QueryBuilder";
import { IPaginationOptions } from "../../interfaces/pagination";
import prisma from "../../shared/prisma";

// Import TypedSQL functions (generated by prisma generate --sql)
// These will be available after running: yarn db:generate
// Temporarily commented out until SQL files are generated
/*
import { 
  getPapersWithPagination, 
  countPapers,
  searchPapers 
} from "@prisma/client/sql";
*/

/**
 * Paper Service demonstrating both QueryBuilder and TypedSQL usage
 */
export class PaperService {
  /**
   * Get all papers using QueryBuilder (for dynamic filtering)
   */
  static async getAllWithQueryBuilder(
    params: any,
    options: IPaginationOptions
  ) {
    const query = { ...params, ...options };

    const searchableFields = ["title", "abstract", "source"];

    const queryBuilder = QueryBuilder.create("paper", query)
      .search(searchableFields)
      .filter()
      .sort()
      .paginate()
      .include({
        uploader: {
          select: {
            id: true,
            email: true,
          },
        },
        chunks: {
          select: {
            id: true,
          },
        },
      });

    const result = await queryBuilder.executeWithMeta(prisma.paper);
    return result;
  }

  /**
   * Get papers using TypedSQL (for optimized, complex queries)
   * TODO: Uncomment after running `yarn db:generate` to generate TypedSQL functions
   */
  static async getAllWithTypedSQL(limit: number = 10, skip: number = 0) {
    // Fallback to Prisma Client until TypedSQL is generated
    const [papers, total] = await Promise.all([
      prisma.paper.findMany({
        skip,
        take: limit,
        where: { isDeleted: false },
        include: {
          uploader: {
            select: {
              id: true,
              email: true,
            },
          },
        },
        orderBy: { createdAt: "desc" },
      }),
      prisma.paper.count({ where: { isDeleted: false } }),
    ]);

    const page = Math.floor(skip / limit) + 1;
    const totalPage = Math.ceil(total / limit);

    return {
      result: papers,
      meta: {
        page,
        limit,
        total,
        totalPage,
      },
    };

    /* 
    // TODO: Enable this after running `yarn db:generate`
    try {
      // Use generated TypedSQL functions for better performance
      const [papers, totalResult] = await Promise.all([
        prisma.$queryRawTyped(getPapersWithPagination(limit, skip)),
        prisma.$queryRawTyped(countPapers())
      ]);

      const total = totalResult[0]?.total || 0;
      const page = Math.floor(skip / limit) + 1;
      const totalPage = Math.ceil(total / limit);

      return {
        result: papers,
        meta: {
          page,
          limit,
          total: Number(total),
          totalPage,
        },
      };
    } catch (error) {
      console.error('Error in getAllWithTypedSQL:', error);
      throw error;
    }
    */
  }

  /**
   * Search papers using TypedSQL with relevance scoring
   * TODO: Uncomment after running `yarn db:generate` to generate TypedSQL functions
   */
  static async searchWithTypedSQL(searchTerm: string) {
    // Fallback to Prisma Client until TypedSQL is generated
    const papers = await prisma.paper.findMany({
      where: {
        isDeleted: false,
        OR: [
          {
            title: {
              contains: searchTerm,
              mode: "insensitive",
            },
          },
          {
            abstract: {
              contains: searchTerm,
              mode: "insensitive",
            },
          },
          {
            source: {
              contains: searchTerm,
              mode: "insensitive",
            },
          },
        ],
      },
      include: {
        uploader: {
          select: {
            id: true,
            email: true,
          },
        },
      },
      orderBy: { createdAt: "desc" },
    });

    return {
      result: papers,
      meta: {
        searchTerm,
        count: papers.length,
      },
    };

    /*
    // TODO: Enable this after running `yarn db:generate`
    try {
      // Use TypedSQL for complex search with relevance scoring
      const papers = await prisma.$queryRawTyped(searchPapers(searchTerm));
      
      return {
        result: papers,
        meta: {
          searchTerm,
          count: papers.length,
        },
      };
    } catch (error) {
      console.error('Error in searchWithTypedSQL:', error);
      throw error;
    }
    */
  }

  /**
   * Get paper by ID using QueryBuilder
   */
  static async getById(id: string) {
    const queryBuilder = QueryBuilder.create("paper", {}).include({
      uploader: {
        select: {
          id: true,
          email: true,
        },
      },
      chunks: true,
      collections: {
        include: {
          collection: {
            select: {
              id: true,
              name: true,
            },
          },
        },
      },
    });

    const query = queryBuilder.build();
    query.where = { id, isDeleted: false };

    const paper = await prisma.paper.findFirst(query);
    return paper;
  }

  /**
   * Create paper with QueryBuilder validation
   */
  static async create(data: any, uploaderId: string) {
    const paper = await prisma.paper.create({
      data: {
        ...data,
        uploaderId,
        isDeleted: false,
      },
      include: {
        uploader: {
          select: {
            id: true,
            email: true,
          },
        },
      },
    });

    return paper;
  }

  /**
   * Update paper with QueryBuilder
   */
  static async update(id: string, data: any) {
    const paper = await prisma.paper.update({
      where: {
        id,
        isDeleted: false,
      },
      data,
      include: {
        uploader: {
          select: {
            id: true,
            email: true,
          },
        },
      },
    });

    return paper;
  }

  /**
   * Soft delete paper
   */
  static async delete(id: string) {
    const paper = await prisma.paper.update({
      where: { id },
      data: { isDeleted: true },
    });

    return paper;
  }

  /**
   * Get papers by user with QueryBuilder
   */
  static async getByUser(
    userId: string,
    params: any,
    options: IPaginationOptions
  ) {
    const query = {
      ...params,
      ...options,
      uploaderId: userId,
    };

    const searchableFields = ["title", "abstract", "source"];

    const queryBuilder = QueryBuilder.create("paper", query)
      .search(searchableFields)
      .filter()
      .sort()
      .paginate()
      .include({
        chunks: {
          select: {
            id: true,
          },
        },
      });

    const result = await queryBuilder.executeWithMeta(prisma.paper);
    return result;
  }

  /**
   * Get papers with date range filtering
   */
  static async getByDateRange(
    startDate?: string,
    endDate?: string,
    options: IPaginationOptions = {}
  ) {
    const query = { ...options };

    const queryBuilder = QueryBuilder.create("paper", query)
      .filter()
      .dateRange("createdAt", startDate, endDate)
      .sort()
      .paginate()
      .include({
        uploader: {
          select: {
            id: true,
            email: true,
          },
        },
      });

    const result = await queryBuilder.executeWithMeta(prisma.paper);
    return result;
  }
}

export const paperService = {
  getAllWithQueryBuilder: PaperService.getAllWithQueryBuilder,
  getAllWithTypedSQL: PaperService.getAllWithTypedSQL,
  searchWithTypedSQL: PaperService.searchWithTypedSQL,
  getById: PaperService.getById,
  create: PaperService.create,
  update: PaperService.update,
  delete: PaperService.delete,
  getByUser: PaperService.getByUser,
  getByDateRange: PaperService.getByDateRange,
};
